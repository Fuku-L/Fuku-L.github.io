

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fishes.png">
  <link rel="icon" href="/img/fishes.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Fuku Lee">
  <meta name="keywords" content="">
  
  <title>二叉树专题 - Fuku</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/diy/shubiao.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":true},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>F's Log</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://gitee.com/fuku-lee/blog-pic-store/raw/master/img/20210427005926.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="二叉树专题">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-10-12 11:28" pubdate>
        2022年10月12日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      49
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">二叉树专题</h1>
            
            <div class="markdown-body">
              <p>三种题型</p>
<h1 id="搜索类"><a href="#搜索类" class="headerlink" title="搜索类"></a>搜索类</h1><p>搜索类只有两种解法，那就是 DFS 和 BFS。几乎所有的搜索类题目都可以方便地使用递归来实现<br>所有搜索类的题目只要把握三个核心点，即<strong>开始点</strong>，<strong>结束点</strong>和<strong>目标</strong>即可。</p>
<h2 id="DFS搜索"><a href="#DFS搜索" class="headerlink" title="DFS搜索"></a>DFS搜索</h2><p>DFS 搜索类的基本套路就是从入口开始做 dfs，然后在 dfs 内部判断是否是结束点，这个结束点通常是叶子节点或空节点，关于结束这个话题我们放在七个技巧中的边界部分介绍，如果目标是一个基本值（比如数字）直接返回或者使用一个全局变量记录即可，如果是一个数组，则可以通过扩展参数的技巧来完成，关于扩展参数，会在七个技巧中的参数扩展部分介绍。 这基本就是搜索问题的全部了，当你读完后面的七个技巧，回头再回来看这个会更清晰。</p>
<h3 id="DFS搜索模板"><a href="#DFS搜索模板" class="headerlink" title="DFS搜索模板"></a>DFS搜索模板</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">root, path</span>):</span><br>    <span class="hljs-comment"># 如果是空结点</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span><br>    <span class="hljs-comment"># 如果是叶子节点</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root.Left <span class="hljs-keyword">and</span> root.Right: <span class="hljs-keyword">return</span><br>    <span class="hljs-comment"># 记录路径</span><br>    path.append(root)<br>    <span class="hljs-comment"># 主要处理逻辑（前序遍历）</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-comment"># 递归左子树和右子树</span><br>    dfs(root.Left, path)<br>    dfs(root.Right, path)<br><br>    <span class="hljs-comment"># 弹出path中的最后一个结点</span><br>    <span class="hljs-comment"># 需要弹出，不然会错误计算。</span><br>    <span class="hljs-comment"># 比如对于如下树：</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">              5</span><br><span class="hljs-string">             / \</span><br><span class="hljs-string">            4   8</span><br><span class="hljs-string">           /   / \</span><br><span class="hljs-string">          11  13  4</span><br><span class="hljs-string">         /  \    / \</span><br><span class="hljs-string">        7    2  5   1</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 如果不 pop，那么 5 -&gt; 4 -&gt; 11 -&gt; 2 这条路径会变成 5 -&gt; 4 -&gt; 11 -&gt; 7 -&gt; 2，其 7 被错误地添加到了 path</span><br><br>    path.pop()<br>    <span class="hljs-comment"># 逻辑也可以写这里，此时是后序遍历</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-comment"># ...</span><br><br>    <span class="hljs-keyword">return</span> 你想返回的数据<br></code></pre></div></td></tr></table></figure>


<p>例题：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a> :开始点是根节点， 结束点是叶子节点，目标就是路径。<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree/">1372. 二叉树中的最长交错路径</a>:从任意节点开始，到任意节点结束的所有交错路径全部搜索出来，挑选出最长的</p>
<h2 id="BFS搜索"><a href="#BFS搜索" class="headerlink" title="BFS搜索"></a>BFS搜索</h2><p>大多数题目是求距离，套用两种模板即可。</p>
<h3 id="BFS搜索模板"><a href="#BFS搜索模板" class="headerlink" title="BFS搜索模板"></a>BFS搜索模板</h3><ol>
<li>标记层：求距离某结点距离等于（大于/小于）k的所有结点。需要记录是第几步。<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solutin</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">k</span>):</span><br>        <span class="hljs-comment"># 使用双端队列，而不是数组。双端队列的底层实现为链表,数组从头部删除元素的时间复杂度为O(n),双端队列删除头部元素为O(1)</span><br>        queue = collections.deque([root])<br>        <span class="hljs-comment"># 记录层数</span><br>        steps = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 需要返回的结点</span><br>        ans = []<br>        <span class="hljs-comment"># 队列不为空,生命不止!</span><br>        <span class="hljs-keyword">while</span> queue:<br>            size = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-comment"># 遍历当前层所有节点</span><br>            <span class="hljs-keyword">for</span> _ <span class="hljs-built_in">int</span> <span class="hljs-built_in">range</span>(size):<br>                node = queue.popleft()<br>                <span class="hljs-keyword">if</span> (step == k) ans.append(node)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <br>            <span class="hljs-comment"># 遍历完当前层所有的节点后 steps + 1</span><br>            steps += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></div></td></tr></table></figure></li>
<li>非标记层：寻找最短距离/路径<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">k</span>):</span><br>        queue = colletions.deque([root])<br><br>        <span class="hljs-keyword">while</span> queue:<br>            node = queue.popleft()<br>            <span class="hljs-keyword">if</span> (node 是我们要找的) <span class="hljs-keyword">return</span> node<br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure></li>
</ol>
<h1 id="构建类"><a href="#构建类" class="headerlink" title="构建类"></a>构建类</h1><p>构建类分为: 普通二叉树的构建 和 二叉搜索树的构建</p>
<h2 id="普通二叉树的构建"><a href="#普通二叉树的构建" class="headerlink" title="普通二叉树的构建"></a>普通二叉树的构建</h2><p>普通二叉树的构建:</p>
<ol>
<li>给定两种DFS遍历的结果数组,构建出原始的树结构.<a target="_blank" rel="noopener" href="https://lucifer.ren/blog/2020/02/08/%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/">构造二叉树系列</a></li>
<li>给定BFS遍历的结果数组,构建出原始的树结构.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></li>
<li>描述一种场景，让你构造一个符合条件的二叉树.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></li>
</ol>
<h2 id="二叉搜索树的构建"><a href="#二叉搜索树的构建" class="headerlink" title="二叉搜索树的构建"></a>二叉搜索树的构建</h2><p>普通二叉树无法区分左右子树,只知道根节点.需要<code>两种遍历序列数组</code>才能构建.<br><code>二叉搜索树的根节点大于所有左子树的值,且小于所有右子树的值.</code>所以可以根据一种遍历序列构建出二叉搜索树.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/">1008. 前序遍历构造二叉搜索树</a></p>
<h1 id="修改类"><a href="#修改类" class="headerlink" title="修改类"></a>修改类</h1><p>修改类题目基于搜索算法,分为两种基本类型.</p>
<h2 id="题目要求的修改"><a href="#题目要求的修改" class="headerlink" title="题目要求的修改"></a>题目要求的修改</h2><p>指明增加/删除节点,或者是修改节点的值或者指向.</p>
<p>例题:</p>
<ol>
<li><p>修改节点的指向:<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a> 修改指针类型,BFS时顺便记录上一次访问的同层节点,然后增加一个指针. — 解法:套用<code>带层的BFS模板</code></p>
</li>
<li><p>增加和删除节点.<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a> 和 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a> — 解法:<code>后序遍历+虚拟节点</code></p>
</li>
</ol>
<blockquote>
<p>实际工程中,可以不删除节点,给节点做一个标记,表示已被删除 – 软删除</p>
</blockquote>
<h2 id="算法需要-自己修改"><a href="#算法需要-自己修改" class="headerlink" title="算法需要,自己修改"></a>算法需要,自己修改</h2><p>为了方便计算,自己增加指针之类的.</p>
<p>例题:</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点</a> –解法:通过修改树的节点类,增加一个指向父节点的引用 parent, 将问题转为距离目标节点一定距离的问题, 用<code>带层的BFS模板</code></p>
<p>动态语言可以直接添加属性(parent指针),静态语言不允许(比如java)需要增加一个新的类定义 或者 使用字典来实现. key 是 node 引用, value 是想记录的东西,比如这里的parent节点.<br>例如:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;<br>    Map&lt;TreeNode, TreeNode&gt; parent;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreenNode node, TreeNode parent)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>            parent.put(node, parent);<br>            dfs(node.left, node);<br>            dfs(node.right, node);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>




<h1 id="四个概念"><a href="#四个概念" class="headerlink" title="四个概念"></a>四个概念</h1><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h3><ul>
<li>没有键值相等的节点</li>
<li>若左子树不为空，则左子树上所有节点的值均小于它的根节点的值</li>
<li>若右子树不为空，则右子树上所有节点的值均大于它的根节点的值</li>
<li>其左、右子树也是二叉排序树</li>
</ul>
<blockquote>
<p>对于二叉排序树，常规操作有<code>插入，查找，删除，找父节点，求最大值，求最小值</code></p>
</blockquote>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>二叉搜索树的中序遍历是有序的。</li>
</ul>
<p>例题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a>  – 进行中序遍历，一边遍历一边判断遍历结果是否是单调递增的</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-univalue-subtrees/">250. 统计同值子树</a></li>
</ul>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>一棵深度为k的，有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号。如果编号为 i （1&lt;=i&lt;=n） 的结点与<code>满二叉树</code>中编号为 i 的结点在二叉树中的位置相同，则称此二叉树为完全二叉树。</p>
<p>完全二叉树编号结构如下图：<br><img src="https://gitee.com/fuku-lee/blog-pic-store/raw/master/img/20211122143337.png" srcset="/img/loading.gif" lazyload alt="image-20211122143328511"><br>这样，父子之间的关系可以通过编号求出。</p>
<p>已知某一结点编号为 i, 其左孩子结点为 <code>2*i</code>, 右孩子结点编号为 <code>2*i+1</code>，父亲结点为 <code>i/2</code>.</p>
<p>例题：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222.完全二叉树的结点个数</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/">662.二叉树最大宽度</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></p>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>要明白路径的概念，以及如何解决这种题，只需要看一个题目就好了 <a target="_blank" rel="noopener" href="https://github.com/azl397985856/leetcode/blob/master/problems/124.binary-tree-maximum-path-sum.md">124.二叉树中的最大路径和</a></p>
<p>类似题目：<a target="_blank" rel="noopener" href="https://github.com/azl397985856/leetcode/blob/master/problems/113.path-sum-ii.md">113.路径综合Ⅰ</a></p>
<h2 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h2><p>和路径类似，距离也是一个相似且频繁出现的一个考点，并且二者都是<code>搜索类题目</code>的考点。原因就在于<code>最短路径就是距离</code>，而树的最短路径就是边的数目。</p>
<p>练习题目：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-distances-in-tree/description/">834.树中距离之和</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/description/">863.二叉树中所有距离为 K 的结点</a></li>
</ul>
<h1 id="七个技巧"><a href="#七个技巧" class="headerlink" title="七个技巧"></a>七个技巧</h1><p>这七个技巧全部是基于 dfs 的，bfs 掌握了模板就行，基本没有什么技巧可言。</p>
<h2 id="dfs-root"><a href="#dfs-root" class="headerlink" title="dfs(root)"></a>dfs(root)</h2><h2 id="单-双递归"><a href="#单-双递归" class="headerlink" title="单/双递归"></a>单/双递归</h2><p>当题目中包含<code>从任意节点开始xxx或者所有xxx</code>的说法时，考虑使用双递归。<br>如果递归中存在<code>重复计算</code>，可以使用<code>双递归+记忆化</code>或者直接单递归。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/paths-with-sum-lcci/">面试题 04.12. 求和路径</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-tilt/description/">563.二叉树的坡度</a></li>
</ul>
<blockquote>
<p>双递归的基本套路就是一个主递归函数和一个内部递归函数。主递归函数负责计算以某一个节点开始的 xxxx，内部递归函数负责计算 xxxx，这样就实现了以所有节点开始的 xxxx。</p>
</blockquote>
<p>典型的加法双递归模板：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs_inner</span>(<span class="hljs-params">root</span>):</span><br>    <span class="hljs-comment"># 这里写逻辑，前序遍历</span><br>    dfs_inner(root.left)<br>    dfs_inner(root.right)<br>    <span class="hljs-comment"># 这里写逻辑，后序遍历</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs_main</span>(<span class="hljs-params">root</span>):</span><br>    <span class="hljs-keyword">return</span> dfs_inner(root) + dfs_main(root.left) + dfs_main(root.right)<br></code></pre></div></td></tr></table></figure>




<h2 id="前后遍历"><a href="#前后遍历" class="headerlink" title="前后遍历"></a>前后遍历</h2><p>和链表一样， 要掌握树的前后序，也只需要记住一句话就好了。那就是<strong>如果是前序遍历，那么你可以想象上面的节点都处理好了，怎么处理的不用管。相应地如果是后序遍历，那么你可以想象下面的树都处理好了，怎么处理的不用管。</strong>这句话的正确性也是毋庸置疑。</p>
<ul>
<li>自顶向下就是在每个递归层级，首先访问节点来计算一些值，并在递归调用函数时将这些值传递到子节点，一般是通过参数传到子树中。</li>
<li>自底向上是另一种常见的递归方法，首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。 – 通常使用后序遍历，需要返回子树结果</li>
</ul>
<p>关于前后序的思维技巧，可以参考 <a target="_blank" rel="noopener" href="https://lucifer.ren/blog/2020/11/08/linked-list/">这个文章</a> 的前后序部分。</p>
<h3 id="总结下经验："><a href="#总结下经验：" class="headerlink" title="总结下经验："></a>总结下经验：</h3><ul>
<li>大多数树的题使用后序遍历比较简单，并且大多需要依赖左右子树的返回值。比如 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/">1448. 统计二叉树中好节点的数目</a></li>
<li>不多的问题需要前序遍历，而前序遍历通常要结合参数扩展技巧。比如 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers/">1022. 从根到叶的二进制数之和</a></li>
<li>如果你能使用参数和节点本身的值来决定什么应该是传递给它子节点的参数，那就用前序遍历。</li>
<li>如果对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出当前节点的答案，那就用后序遍历。</li>
<li>如果遇到二叉搜索树则考虑中序遍历</li>
</ul>
<h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>是的！不仅仅链表有虚拟节点的技巧，树也是一样。关于这点大家可能比较容易忽视。</p>
<p>回忆一下链表的虚拟指针的技巧，我们通常在什么时候才会使用？</p>
<p>其中一种情况是链表的头会被修改。这个时候通常需要一个虚拟指针来做新的头指针，这样就不需要考虑第一个指针的问题了（因为此时第一个指针变成了我们的虚拟指针，而虚拟指针是不用参与题目运算的）。树也是一样，当你需要对树的头节点（在树中我们称之为根节点）进行修改的时候， 就可以考虑使用虚拟指针的技巧了。<br>另外一种是题目需要返回树中间的某个节点（不是返回根节点）。实际上也可借助虚拟节点。由于我上面提到的指针的操作，实际上，你可以新建一个虚拟头，然后让虚拟头在恰当的时候（刚好指向需要返回的节点）断开连接，这样我们就可以返回虚拟头的 next 就 ok 了。<br>更多关于虚拟指针的技巧可以参考<a target="_blank" rel="noopener" href="https://lucifer.ren/blog/2020/11/08/linked-list/">这个文章</a> 的虚拟头部分。</p>
<p>例题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-pruning/">814. 二叉树剪枝</a> – 虚拟头节点+后序遍历返回子树节点和</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-leaves-with-a-given-value/">1325. 删除给定值的叶子节点</a> – 虚拟头节点+后序遍历+参数扩展</li>
</ul>
<p>树的删除和链表删除类似，<strong>树的删除需要父节点</strong>，因此这里的技巧和链表类似，记录一下当前节点的父节点即可，并通过<strong>参数扩展</strong>向下传递。</p>
<h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p>树有三种题型，对于不同的题型其实边界考虑的侧重点也是不一样的。</p>
<ul>
<li>搜索类 （空节点、叶子节点）</li>
<li>构建类</li>
<li>修改类<h3 id="搜索类-1"><a href="#搜索类-1" class="headerlink" title="搜索类"></a>搜索类</h3>边界情况有两类：</li>
</ul>
<ol>
<li>空节点<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">root</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;是空节点，需要返回合适的值&#x27;</span>)<br>    <span class="hljs-comment"># ...其他逻辑，前序遍历 or 后序遍历</span><br></code></pre></div></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        fmt.Print(<span class="hljs-string">&quot;是空节点，需要返回合适的值&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 继续处理其他逻辑,前序遍历</span><br>    dfs(root.Left)<br>    dfs(root.Right)<br>    <span class="hljs-comment">//  后序遍历</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li>叶子节点<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">root</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;是空节点，需要返回合适的值&#x27;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> root.right: <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;是叶子节点，需要返回合适值&#x27;</span>)<br>    <span class="hljs-comment"># ...其他逻辑，前序遍历 or 后序遍历</span><br></code></pre></div></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        fmt.Print(<span class="hljs-string">&quot;是空节点,需要返回合适的值&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        fmt.Print(<span class="hljs-string">&quot;是叶子节点,需要返回合适的值&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// ...其他逻辑，前序遍历 or 后序遍历</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="构建类-1"><a href="#构建类-1" class="headerlink" title="构建类"></a>构建类</h3></li>
<li>参数扩展的边界<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/">1008.根据前序遍历构建二叉搜索树</a></li>
<li>虚拟节点<br>除了搜索类的技巧可以用于构建类外，也可以考虑用我上面的讲的虚拟节点。<h3 id="修改类-1"><a href="#修改类-1" class="headerlink" title="修改类"></a>修改类</h3>???</li>
</ol>
<h2 id="参数扩展大法"><a href="#参数扩展大法" class="headerlink" title="参数扩展大法"></a>参数扩展大法</h2><p>如果不需要考虑参数扩展,最简单的dfs通常是:</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">root</span>):</span><br>    <span class="hljs-comment">#do something</span><br></code></pre></div></td></tr></table></figure>

<p>有时候,dfs需要携带其他有用的信息.有以下三种典型情况:</p>
<ol>
<li><p>携带父亲或者爷爷节点信息:</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">root, parent</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span><br>    dfs(root.left, root)<br>    dfs(root.right, root)<br></code></pre></div></td></tr></table></figure></li>
<li><p>携带路径信息,可以是路径和或者具体的路径数组等</p>
</li>
</ol>
<ul>
<li>路径和:<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">root, path_sum</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-comment"># 这里可以拿到根到叶子的路径和</span><br>        <span class="hljs-keyword">return</span> path_sum<br>    dfs(root.left, path_sum + root.val)<br>    dfs(root.right, path_sum + root.val)<br></code></pre></div></td></tr></table></figure></li>
<li>路径:<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">root, path</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-comment"># 这里可以拿到根到叶子的路径</span><br>        <span class="hljs-keyword">return</span> path<br>        path.append(root.val)<br>        dfs(root.left, path)<br>        dfs(root.right, path)<br>        <span class="hljs-comment"># 撤销</span><br>        path.pop()<br></code></pre></div></td></tr></table></figure></li>
</ul>
<p>例题:<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/paths-with-sum-lcci/">面试题 04.12. 求和路径</a></p>
<ol start="3">
<li>二叉搜索树的搜索题大多数都需要扩展参考，甚至怎么扩展都是固定的。<blockquote>
<p>二叉搜索树的搜索总是将最大值和最小值通过参数传递到左右子树，类似 dfs(root, lower, upper)，然后在递归过程更新最大和最小值即可。这里需要注意的是 (lower, upper) 是的一个左右都开放的区间。</p>
</blockquote>
</li>
</ol>
<p>使用 扩展参数大法中 <code>左右边界法</code><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">783. 二叉搜索树节点最小距离</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/">1026. 节点与其祖先之间的最大差值</a></p>
<p>模板:</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minDiffInBST</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">root, lower, upper</span>):</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>                <span class="hljs-keyword">return</span> upper - lower<br>            left = dfs(root.left, lower, node.val)<br>            right = dfs(root.right, node.val, upper)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(left, right)<br>        <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>),<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>))<br></code></pre></div></td></tr></table></figure>

<h2 id="返回元组-列表"><a href="#返回元组-列表" class="headerlink" title="返回元组/列表"></a>返回元组/列表</h2><p>通常dfs返回值是一个单值,但为了方便计算,有时候会返回一个数组或者元组.</p>
<ol>
<li>返回元组</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/">865.具有所有最深节点的最小子树</a>  – dfs返回深度,通过比较左右子树的深度来定位答案(最深节点的位置)</p>
<p>返回单值,用来定位最深节点位置,但是865要求返回节点,所以需要返回同时返回根节点</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subtreeWithAllDeepest</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">node, d</span>):</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node: <span class="hljs-keyword">return</span> d<br>            l_d = dfs(node.left, d + <span class="hljs-number">1</span>)<br>            r_d = dfs(node.right, d + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">if</span> l_d &gt;= r_d: <span class="hljs-keyword">return</span> l_d<br>            <span class="hljs-keyword">return</span> r_d<br>        <span class="hljs-keyword">return</span> dfs(root, -<span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure>

<p>题目要求返回的是树节点的引用啊，这个时候应该考虑返回元祖，即<strong>除了返回深度，也要把节点给返回</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subtreeWithAllDeepest</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">node, depth</span>):</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node: <span class="hljs-keyword">return</span> (node, depth)<br>            l,l_d = dfs(node.left, depth+<span class="hljs-number">1</span>)<br>            r, r_d = dfs(node.right, depth+<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">if</span> l_d &gt;= r_d: <span class="hljs-keyword">return</span> (node,l_d)<br>            <span class="hljs-keyword">return</span> (r, r_d)<br>        <span class="hljs-keyword">return</span> dfs(root, -<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br></code></pre></div></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subtreeWithAllDeepest</span><span class="hljs-params">(root *TreeNode)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>	ans,_ := dfs(root,<span class="hljs-number">-1</span>)<br>	<span class="hljs-keyword">return</span> ans<br>&#125;<br><span class="hljs-comment">// dfs 返回 root 节点以及最深路径</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, depth <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*TreeNode, <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	<span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> root, depth<br>	&#125;<br>	l, l_d := dfs(root.Left, depth+<span class="hljs-number">1</span>)<br>	r, r_d := dfs(root.Right, depth+<span class="hljs-number">1</span>)<br>	<span class="hljs-keyword">if</span> l_d == r_d &#123;<br>		<span class="hljs-keyword">return</span> root, l_d<br>	&#125; <br>	<span class="hljs-keyword">if</span> l_d &gt; r_d &#123;<br>		<span class="hljs-keyword">return</span> l, l_d<br>	&#125;<br>	<span class="hljs-keyword">return</span> r, r_d<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ol start="2">
<li>返回数组<br>需要用到笛卡尔积的时候，考虑使用返回数组的方式。<blockquote>
<p>一般来说，如果需要使用笛卡尔积的情况还是比较容易看出的。另外一个不太准确的技巧是，如果题目有”所有可能“，”所有情况“，可以考虑使用此技巧。</p>
</blockquote>
</li>
</ol>
<p>典型例题：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/description/">1530.好叶子节点对的数量</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/all-possible-full-binary-trees/description/">894. 所有可能的满二叉树</a></p>
<p>练习题：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a><br><a target="_blank" rel="noopener" href="https://github.com/azl397985856/leetcode/blob/master/problems/101.symmetric-tree.md">101. 对称二叉树</a><br><a target="_blank" rel="noopener" href="https://github.com/azl397985856/leetcode/blob/master/problems/226.invert-binary-tree.md">226. 翻转二叉树</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flip-binary-tree-to-match-preorder-traversal/">971. 翻转二叉树以匹配先序遍历</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/">987. 二叉树的垂序遍历</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/successor-lcci/">面试题 04.06. 后继者</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/lc/">lc</a>
                    
                      <a class="hover-with-bg" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/lc-0011-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">lc-0011.盛最多水的容器</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/DataBase-TIDB-study-03-Oracle%E7%9A%84%E7%94%A8%E6%88%B7%E5%88%9B%E5%BB%BA%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%9D%83%E9%99%90/">
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>














  
<script src="/js/diy/caidai.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
